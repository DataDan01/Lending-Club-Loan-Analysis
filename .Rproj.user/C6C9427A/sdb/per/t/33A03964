{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Lending Club Loan Data - Exploratory Analysis\"\noutput:\n  html_notebook:\n    code_folding: hide\n  html_document: default\n---\n\n```{r, message = FALSE, warning = FALSE}\n# This function installs any libraries that are missing and needed for the script\nlib_load <- function(package) {\n\n  if(!(package %in% rownames(installed.packages()))) {\n    \n      message(sprintf(\"This portion of the code requires the %s library\\nIt doesn't look like you have it installed\\nWould you like to install it now?\", \n              package))\n    \n      response <- readline(prompt = \"Enter Y or N: \")\n    \n      if(toupper(response) == \"Y\") {\n        install.packages(package)\n        library(package, character.only = T)\n        return(cat(\"Installed and loaded package\"))\n      }\n      \n      if(toupper(response) == \"N\") return(cat(\"Package not installed\"))\n  } else\n    return(library(package, character.only = T))\n}\n\n# Downloading/loading the data file and dictionary\nlib_load(\"data.table\")\nlib_load(\"openxlsx\")\nlib_load(\"dplyr\")\n\nif(!all(c(\"LoanStats_2017Q1.csv\",\"LCDataDictionary.xlsx\") %in% list.files(\"../Data\"))) {\n\n  message(\"Downloading and reading in data\")\n  \n  # Getting the data files\n  temp <- tempfile()\n  download.file(\"https://resources.lendingclub.com/LoanStats_2017Q1.csv.zip\", temp, mode = \"wb\")\n  unzip(zipfile = temp, files = \"LoanStats_2017Q1.csv\", exdir = \"../Data\")\n  loan_data <- fread(\"../Data/LoanStats_2017Q1.csv\", data.table = F); rm(temp)\n\n  download.file(\"https://resources.lendingclub.com/LCDataDictionary.xlsx\", \n                \"../Data/LCDataDictionary.xlsx\", method = \"curl\")\n  \n  # Downloading and combining the data dictionary spreadsheet\n  data_dict <- list(read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 1),\n                     read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 2),\n                     read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 3))\n  \n  data_dict <- lapply(data_dict, function(df) { \n        colnames(df) <- c(\"var\",\"desc\") \n        return(df)\n      }) %>% rbindlist() %>% unique()\n  \n} else {\n  \n  message(\"Loading in the data\")\n  \n  loan_data <- fread(\"../Data/LoanStats_2017Q1.csv\", data.table = F)\n  \n  data_dict <- list(read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 1),\n                   read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 2),\n                   read.xlsx(\"../Data/LCDataDictionary.xlsx\", sheet = 3))\n  \n  data_dict <- lapply(data_dict, function(df) { \n        colnames(df) <- c(\"var\",\"desc\") \n        return(df)\n      }) %>% rbindlist() %>% unique()\n}\n\n## Basic data scrubbing ahead of analysis ##\n\n# Dropping blank or redacted columns\nloan_data[,c(\"id\",\"member_id\",\"url\",\"desc\",\"zip_code\",\"policy_code\")] = NULL\n\n# Extracting numbers out of strings and converting to the numeric type\nloan_data[,c(\"int_rate\",\"revol_util\")] <- sapply(loan_data[,c(\"int_rate\",\"revol_util\")], \n                                                       \n function(mixed_string) {\n   \n  gsub(pattern = \"[^\\\\d|.]+\", replacement = \"\", x = mixed_string, perl = TRUE) %>% as.numeric()\n  \n})\n\n# Making every other non-string a numeric value\nloan_data[,c(1:3,5,6,12,20,21,23:30,32:40,42,45:46,48:49,52:106,108:116)] <- \n  loan_data[,c(1:3,5,6,12,20,21,23:30,32:40,42,45:46,48:49,52:106,108:116)] %>% \n                        sapply(as.numeric) \n\n# Trimming leading and trailing whitespace from character vectors\nloan_data[,unlist(lapply(loan_data,class)) == \"character\"] = sapply(loan_data[,unlist(lapply(loan_data,class)) == \"character\"], trimws)\n\n# Grabbing all of the column classes\ncol_classes <- table(unlist(lapply(loan_data,class)))\n```\n\n## Introduction\n\n[Lending Club](https://www.lendingclub.com/) is a peer-to-peer lending company that matches borrowers with investors through an online platform. It services people that need personal loans between $1,000 and $40,000. Borrowers receive the full amount of the issued loan minus the origination fee, which is paid to the company. Investors purchase notes backed by the personal loans and pay Lending Club a service fee. The company shares data about all loans issued through its platform during certain time periods. \n\nThis analysis will focus on the Lending Club [Loan Data](https://www.lendingclub.com/info/download-data.action) from the first quarter of 2017. This document is generated using [R Markdown](http://rmarkdown.rstudio.com/). The code that powers the analysis is hidden by default but you can expand any section by clicking the **Code** button, like the one in the top right corner of this section. So far I have loaded in the actual data file and the data dictionary. I also performed some minor formatting to prepare for the rest of the analysis.\n\nWe'll start off by running some broad summary statistics and using this information to clean up the data set. Once the data are reasonably formatted we will move on to visualizing the relationships between the variables.\n\n## Broad Summary Statistics and Scrubbing\n\nBefore we start any analysis or data scrubbing, let's join in the [data dicionary](https://resources.lendingclub.com/LCDataDictionary.xlsx) so we can have a quick reference to what the variables actually mean:\n\n```{r, message = FALSE, warning = FALSE}\n# Extracting all data column names and joining to data dictionary\nloan_data_cols <- data.frame(Variable = colnames(loan_data),\n                             stringsAsFactors = F)\n\ndata_dict$var <- trimws(data_dict$var)\n\nmapping <- loan_data_cols %>% left_join(data_dict, by = c(\"Variable\" = \"var\"))\n\ncolnames(mapping)[2] <- \"Full Description\"\n\n# Formatting into interactive HTML table\nlib_load(\"DT\")\n\nmapping <- sapply(mapping, trimws)\n\ndatatable(mapping)\n```\n<br><br>\nWe'll start by taking a broad look at the different variable types in the data set. After dropping some empty and redacted columns we are left with `r dim(loan_data)[2]` variables in total. There appear to be `r col_classes['numeric']` continuous variables and `r col_classes['character']` categorical variables. Let's run some summary statistics on the **continuous variables**:\n\n```{r, message = FALSE, warning = FALSE}\n# Grabbing column types to see if they are categorical or contiunous\nall_vars <- unlist(lapply(loan_data,class))\n\n# Enters zero NAs for summary when there are none so the summary data structures can be combined\n# Borrowed from: https://stackoverflow.com/questions/32011873/force-summary-to-report-the-number-of-nas-even-if-none\ncustom_summary <- function(var) {\n  \n  if(!any(is.na(var))) {\n    res <- c(summary(var),\"NA's\"=0)\n  } else {\n    res <- summary(var)\n  }\n  return(res)\n}\n\n# Extracting continuous variables\ncont_info <- lapply(loan_data[,all_vars == \"numeric\"], custom_summary) \n\n# Formatting summaries into uniform data structure and combining\ncont_names <- names(all_vars[all_vars == \"numeric\"])\n\ncont_info <- lapply(1:length(cont_info), function(inx) {\n  \n  new_vect <- c(cont_names[inx],round(cont_info[[inx]],2))\n  \n  names(new_vect)[1] <- \"Var Name\"\n  \n  new_vect\n  \n}); cont_info <- do.call(rbind,cont_info)\n\n# Formatting into interactive HTML table\ndatatable(cont_info)\n```\n<br><br>   \n\nWe see several variables that describe the loan such as the amount, payment, interest rate, and term. We also see some descriptive information on the borrower such as annual income, debt-to-income ratio (DTI), number of mortgage accounts, and total credit limit. It looks like *dti*, *recoveries*, and *collection_recovery_fee* have some data issues. The latter two are blank throughout the entire data set. The minimum and maximum values on *dti* seem completely off. We can plot the histograms of various *dti* ranges to get more reasonable bounds for the data:  \n\n```{r, message = FALSE, warning = FALSE, fig.width = 9, fig.height = 5, fig.align = \"center\"}\n# First cleaning up the blank variables\nloan_data[,c(\"recoveries\",\"collection_recovery_fee\")] = NULL\n\n# Plotting the density of dti under various cut-offs\ndti_raw <- loan_data$dti\n\nlib_load(\"ggplot2\")\n\ndens1 <- qplot(dti_raw, fill = I(\"dodgerblue4\"), \n               alpha = I(0.4), col = I(\"grey29\")) + xlab(\"dti full range\") + ylab(\"Count\")\n\ndens2 <- qplot(dti_raw[dti_raw > 0 & dti_raw < 15], fill = I(\"dodgerblue4\"), \n               alpha = I(0.4), col = I(\"grey29\")) + xlab(\"0 < dti < 15\") + ylab(\"Count\")\n\ndens3 <- qplot(dti_raw[dti_raw > 0 & dti_raw < 50], fill = I(\"dodgerblue4\"), \n               alpha = I(0.7), col = I(\"grey29\")) + xlab(\"0 < dti < 50\") + ylab(\"Count\")\n\ndens4 <- qplot(dti_raw[dti_raw > 50 & dti_raw < 9999], fill = I(\"dodgerblue4\"), \n               alpha = I(0.4), col = I(\"grey29\")) + xlab(\"50 < dti < 9999\") + ylab(\"Count\")\n\n# Combining density plots\nlib_load(\"gridExtra\")\nlib_load(\"grid\")\n\n# Subjectively clipping range of dti\ngrid.arrange(dens1, dens2, dens3, dens4,\n             top = textGrob(\"DTI Histograms (30 bins)\"), \n             widths = c(4,4), heights = c(4,4))\n\n# Clipping the range for dti\nloan_data$dti[loan_data$dti < 0 | loan_data$dti > 50] = NA\n```\n<br><br>\n\nKeeping the full range for *dti* doesn't seem to make sense. The lower bound should always be zero since you can't have less than no debt. The upper bound is a bit debatable. It appears that the majority of the density is captured between 0 and 50, which seems to be reasonable. We can subjectively drop everything outside of this range and convert those entries to missing values, which are represented as **NA** in the R language. This results in `r sum(is.na(loan_data$dti))` missing entries.\n\nNext, let's take a look at the **categorical variables**. We'll count the frequencies for the top four categories for each variable and lump everything else into a fifth category called *Other*. If there are less than four categories then we'll just show all of the counts.\n\n```{r, message = FALSE, warning = FALSE}\n# Extracting categorical variables\ncat_info <- lapply(1:sum(all_vars == \"character\"), function(inx) {\n  \n  Category <- loan_data[,names(all_vars[all_vars == \"character\"])[inx]]\n  \n  # Getting frequency counts and sorting in decreasing order\n  counts_df <- data.frame(table(Category)) %>% arrange(desc(Freq))\n  counts_df$Category <- as.character(counts_df$Category)\n  \n  # Summarizing only top 4 counts and lumping everything into a fifth category, Other\n  if(nrow(counts_df) > 5) {\n    \n   counts_df$Freq[5] <- sum(counts_df$Freq[5:nrow(counts_df)])\n   counts_df$Category[5] <- \"Other\"\n   \n   counts_df <- counts_df[1:5,]\n  } \n    \n  df <- data.frame(Name = names(all_vars[all_vars == \"character\"])[inx],\n                   counts_df, stringsAsFactors = F)\n\n  df$`Freq %` <- round(100*df$Freq/sum(df$Freq))\n  \n  df\n  \n}) %>% bind_rows()\n\n# Saving example of an incorrectly tagged NA\nbad_row <- which(loan_data$emp_title == \".\")\n\n# Formatting into interactive HTML table\ndatatable(cat_info)\n```\n<br><br>\n\nWe see some descriptive information on the loans such as the term, grade, and purpose. There are also some variables that describe the borrower such as employment title, state of residence, and number of accounts currently delinquent. Columns like *earliest_cr_line* can be converted to an integer that represents the years since that date, which would be more useful for modeling later. There are also entries that are tagged as empty spaces or dots that should really be **NA**. An example is row `r bad_row` for *emp_title*, which is tagged as a period. Let's clean these up. \n\n```{r, message = FALSE, warning = FALSE}\n# Fixing date columns\nlib_load(\"lubridate\")\nlib_load(\"zoo\")\n\n# Earliest credit line is now the years since the given date\nloan_data$earliest_cr_line <- difftime(as.yearmon(loan_data$issue_d, format = \"%b-%Y\"),\n                                       as.yearmon(loan_data$earliest_cr_line, format = \"%b-%Y\"), \n                                       unit = \"weeks\")/52.25\n\nloan_data$earliest_cr_line <- as.numeric(loan_data$earliest_cr_line)\n\nloan_data$sec_app_earliest_cr_line <- difftime(as.yearmon(loan_data$issue_d, format = \"%b-%Y\"),\n                                               as.yearmon(loan_data$sec_app_earliest_cr_line, format = \"%b-%Y\"), \n                                               unit = \"weeks\")/52.25\n\nloan_data$sec_app_earliest_cr_line <- as.numeric(loan_data$sec_app_earliest_cr_line)\n\n# Dropping columns that don't really add any info\nloan_data[,c(\"pymnt_plan\")] = NULL\n\n# Coercing various entries to NA\nloan_data[loan_data == \"\" | loan_data == \".\"] <- NA\n```\n<br><br>\n\nNow that we have cleaned up the variables and correctly tagged missing values as **NA**, let's take a look at the sparsity of various columns. Missing data can have strong impacts on predictive and inferential analysis. It's important to understand any patterns in the sparsity, sometimes dropping incomplete observations can lead to a biased understanding of the data.\n\n```{r, message = FALSE, warning = FALSE}\n# Summarizing variables with lots of NAs\nsparse_count <- lapply(1:ncol(loan_data), function(inx) {\n\n  temp <- loan_data[,inx]\n  \n  Variable = colnames(loan_data)[inx]\n  \n  `NA %` = round(sum(is.na(temp))/length(temp)*100,2)\n  \n  `Full Name` = data_dict$desc[which(Variable == data_dict$var)[1]]\n\n  df <- data.frame(Variable,`NA %`,`Full Name`,\n                   check.names = F,\n                   stringsAsFactors = F)\n  \n  return(df)\n}) %>% bind_rows() %>% arrange(desc(`NA %`))\n\n# Grabbing any variable with at least one NA\nsparse_count <- sparse_count[sparse_count$`NA %` > 0,]\n\ndatatable(sparse_count)\n```\n<br><br>\n\nIt looks like a lot of the missing values are related to variables that deal with a second applicant. It doesn't seem like these are critical to exploratory analysis or inference but we should still keep them in mind. We could explore different ways to impute some of the missing values, especially if we want to use the variables as part of a model for certain types of borrowers.\n\n## Visualzing Distributions\n\n```{r, message = FALSE, warning = FALSE}\n# Getting raw counts of continuous and categorical vars, then getting fully complete ones (no NAs)\ncont <- sapply(loan_data, class) == \"numeric\"\ncat <- sapply(loan_data, class) == \"character\"\n\ncont_full <- sum(!(names(cont[cont == TRUE]) %in% sparse_count$Variable))\ncat_full <- sum(!(names(cat[cat == TRUE]) %in% sparse_count$Variable))\n```\n\nAt this point, we're left with `r cont_full` continuous variables and `r cat_full` categorical variables with no **NA**s. The full data set contains `r sum(cont)` continuous variables and `r sum(cat)` categorical variables. We've also got `r nrow(loan_data)` observations, with each row representing a unique loan. It's a bit difficult to think about this much data at once. A good first step is to create some plots to better understand the most important variables.\n\nFirst, let's try to break out the total loan volume in the first quarter of 2017. Let's get a feel for **who** is borrowing the money, **what** they're using it for, **where** they live, and their **risk** profiles.\n\n```{r, message = FALSE, warning = FALSE, fig.width = 9, fig.height = 5, fig.align = \"center\"}\n# Cleaning up registered nurse double counting across loan_data\nloan_data$emp_title[loan_data$emp_title %in% c(\"RN\",\"Rn\",\"rn\",\"nurse\",\"Nurse\")] <- \"Registered Nurse\"\n\nloan_data$emp_title[is.na(loan_data$emp_title)] <- \"Not Available\"\n\n# Aggregating up total loans by emp_title\nloan_by_emp <- loan_data %>% \n               group_by(emp_title) %>% \n               summarize(`Total Loans ($)` = sum(loan_amnt)) %>%\n               arrange(desc(`Total Loans ($)`))\n\n# Getting percentage information since we can only plot a subset\nloan_by_emp$emp_title <- paste0(loan_by_emp$emp_title,\" - \",paste0(round(100*loan_by_emp$`Total Loans ($)`/sum(loan_by_emp$`Total Loans ($)`),1),\"%\"))\n\nloan_by_emp_plot <- ggplot(loan_by_emp[1:10,], aes(x = reorder(emp_title,-`Total Loans ($)`), \n                                                   y = (`Total Loans ($)`)/1e6, \n                                                   fill = I(\"dodgerblue4\"),\n                                                   alpha = I(rep(0.7,10)),\n                                                   col = I(\"grey29\"))) + \n                    geom_bar(stat = \"identity\") +\n                    theme(axis.text.x = element_text(angle = 55, hjust = 1)) +\n                    xlab(\"Job Title - % of Total\") +\n                    ylab(\"Total Loans - Millions of $\")\n\n# Aggregating up by purpose\nloan_by_purp <- loan_data %>% \n                group_by(title) %>% \n                summarize(`Total Loans ($)` = sum(loan_amnt)) %>%\n                arrange(desc(`Total Loans ($)`))\n\n# Getting percentage information\nloan_by_purp$title <- paste0(loan_by_purp$title,\" - \",paste0(round(100*loan_by_purp$`Total Loans ($)`/sum(loan_by_purp$`Total Loans ($)`),1),\"%\"))\n\nloan_by_purp_plot <- ggplot(loan_by_purp, aes(x = reorder(title,-`Total Loans ($)`), \n                                              y = (`Total Loans ($)`)/1e6, \n                                              fill = I(\"dodgerblue4\"),\n                                              alpha = I(rep(0.7,12)),\n                                              col = I(\"grey29\"))) + \n                     geom_bar(stat = \"identity\") +\n                     theme(axis.text.x = element_text(angle = 55, hjust = 1)) +\n                     xlab(\"Purpose\") +\n                     ylab(NULL)\n\ngrid.arrange(loan_by_emp_plot, loan_by_purp_plot,\n             top = textGrob(\"Total Loans by Job Title and Purpose\"),\n             ncol = 2)\n```\n<br><br>\n\nWe can see that many of the job titles are actually missing, which could be because Lending Club chooses to hide that information to maintain the borrowers' anonymity. Registered Nurse, Manager, Teacher, and Business Owner form the next largest categories. However, these only account for about 7.5% of the loan volume. This distribution has a strong right tail that stretches across the `r nrow(loan_by_emp)` different job titles. The distribution of loan volume by *purpose* is actually the opposite of this. The vast majority of the loans have been taken out to consolidate debt. There are only `r nrow(loan_by_purp)-1` other purposes, which are all shown in the plot.\n\nNow let's take a look at what states the borrowers live in:\n\n```{r, message = FALSE, warning = FALSE, fig.width = 9, fig.height = 5, fig.align = \"center\"}\n# Aggregating up by state\nloan_by_state <- loan_data %>% \n                 group_by(addr_state) %>%\n                 summarize(`Total Loans ($)` = sum(loan_amnt)/1e6) %>%\n                 arrange(desc(`Total Loans ($)`))\n\ncolnames(loan_by_state) <- c(\"region\",\"value\")\n\n# Getting summary percentage of top 4 regions\ntop4_states <- round(100*sum(loan_by_state$value[1:4])/sum(loan_by_state$value),1)\n\n# Replacing out the state codes with their full names for plotting\nlib_load(\"rgdal\")\nlib_load(\"choroplethrMaps\")\nlib_load(\"choroplethr\") # hit \"n\" when installing the sf package, seems to be a bug\n\ndata(\"state.regions\")\n\nloan_by_state$region <- sapply(loan_by_state$region, function(state_code) {\n  \n  inx <- grep(pattern = state_code, x = state.regions$abb)\n  \n  state.regions$region[inx]\n  \n})\n\n# Plotting US map with values\nstate_choropleth(loan_by_state, title = \"           Total Loan Volume by State - Millions $\")\n```\n<br><br>\n\nMost of the funds borrowed through Lending Club in the first quarter for 2017 went to people in California, Texas, New York, and Florida. These regions accounted for `r top4_states`% of the volume during the period. This ranking actually mimics the ranking of those states' economic output as [measured by GDP](https://www.bea.gov/iTable/drilldown.cfm?reqid=70&stepnum=11&AreaTypeKeyGdp=1&GeoFipsGdp=XX&ClassKeyGdp=naics&ComponentKey=200&IndustryKey=1&YearGdp=2016&YearGdpBegin=-1&YearGdpEnd=-1&UnitOfMeasureKeyGdp=levels&RankKeyGdp=1&Drill=1&nRange=5). States with larger economies tend to have people who borrow more. It's also interesting to note that Lending Club loans are currently not available in Iowa or West Virginia.\n\nFinally, we can visualize various measures of the borrowers' risk profiles. We can start off by taking a look at the distribution of the interest rate charged for each *grade* rating.\n\n```{r, message = FALSE, warning = FALSE, fig.width = 9, fig.height = 5, fig.align = \"center\"}\n# Grabbing the means\ncdat <- data.frame(tapply(loan_data$int_rate, loan_data$grade, mean))\n\nrate_grade_dens <- ggplot(loan_data, aes(x = int_rate, fill = grade)) + \n                    geom_density(alpha = 0.6) +\n                      geom_vline(data = cdat, aes(xintercept = cdat, colour =  factor(rownames(cdat))),\n                                 linetype = \"dashed\", size = 1, show.legend = F) +\n                      ylab(NULL) +\n                      xlab(\"Interest Rate\") + \n                      guides( fill = guide_legend(title = \"Loan Grade\")) + \n                      theme(axis.ticks.y = element_blank(), plot.title = element_text(hjust = 0.5)) + \n                      ggtitle(\"Interest Rate Distribution by Grade\")\n\nrate_grade_dens\n```\n\nThe interest rate generally increases as the loan's grade decreases, which is expected. However, these distributions appear to be quite lumpy, which highlights the fact that there are various interest rate subgroups within each grade group. Let's take a deeper look into each *grade* group.\n\n```{r, message = FALSE, warning = FALSE}\nlib_load(\"moments\")\n\n## Generic function to create four descriptive plots for each loan grade --> Employment, State, Purpose, Amount\ngrade_plotter <- function(grade) {\n  \n  # Filtering for grade\n  loan_data_tmp <- loan_data[loan_data$grade == grade,]\n\n  ## Aggregating up total loans by job ##\n  loan_by_emp <- loan_data_tmp %>% \n                 group_by(emp_title) %>% \n                 summarize(`Total Loans ($)` = sum(loan_amnt)) %>%\n                 arrange(desc(`Total Loans ($)`))\n  \n  # Getting percentage information since we can only plot a subset\n  loan_by_emp$emp_title <- paste0(loan_by_emp$emp_title,\" - \",paste0(round(100*loan_by_emp$`Total Loans ($)`/sum(loan_by_emp$`Total Loans ($)`),1),\"%\"))\n  \n  loan_by_emp_plot <- ggplot(loan_by_emp[1:10,], aes(x = reorder(emp_title,-`Total Loans ($)`), \n                                                     y = (`Total Loans ($)`)/1e6, \n                                                     fill = I(\"dodgerblue4\"),\n                                                     alpha = I(rep(0.7,10)),\n                                                     col = I(\"grey29\"))) + \n                      geom_bar(stat = \"identity\") +\n                      theme(axis.text.x = element_text(angle = 55, hjust = 1)) +\n                      xlab(\"Job Title - % of Total\") +\n                      ylab(\"Total Loans - Millions of $\")\n  \n  ## Aggregating up total loans by purpose ##\n  loan_by_purp <- loan_data_tmp %>% \n                  group_by(title) %>% \n                  summarize(`Total Loans ($)` = sum(loan_amnt)) %>%\n                  arrange(desc(`Total Loans ($)`))\n\n  # Getting percentage information\n  loan_by_purp$title <- paste0(loan_by_purp$title,\" - \",paste0(round(100*loan_by_purp$`Total Loans ($)`/sum(loan_by_purp$`Total Loans ($)`),1),\"%\"))\n  \n  loan_by_purp_plot <- ggplot(loan_by_purp, aes(x = reorder(title,-`Total Loans ($)`), \n                                                y = (`Total Loans ($)`)/1e6, \n                                                fill = I(\"dodgerblue4\"),\n                                                alpha = I(rep(0.7,12)),\n                                                col = I(\"grey29\"))) + \n                     geom_bar(stat = \"identity\") +\n                     theme(axis.text.x = element_text(angle = 55, hjust = 1)) +\n                     xlab(\"Purpose\") +\n                     ylab(NULL)\n  \n  ## Aggregating up total loans by state ##\n  loan_by_state <- loan_data_tmp %>% \n                   group_by(addr_state) %>% \n                   summarize(`Total Loans ($)` = sum(loan_amnt)) %>%\n                   arrange(desc(`Total Loans ($)`))  \n  \n  # Finding full state names, capitalizing first letter of each one\n  loan_by_state$addr_state <- sapply(loan_by_state$addr_state, function(state_code) {\n    \n    inx <- grep(pattern = state_code, x = state.regions$abb)\n    \n    state.regions$region[inx]\n  \n  }, USE.NAMES = F)\n  \n  # Borrowed from: https://stackoverflow.com/questions/6364783/capitalize-the-first-letter-of-both-words-in-a-two-word-string\n  loan_by_state$addr_state <- sapply(loan_by_state$addr_state, function(state_name) {\n    \n    split <- strsplit(x=state_name, \" \")[[1]]\n    \n      paste(toupper(substring(split, 1,1)), \n            substring(split, 2), sep=\"\", collapse=\" \")\n  }, USE.NAMES = F)\n  \n  # Getting percentage information especially since we can only plot a subset\n  loan_by_state$addr_state <- paste0(loan_by_state$addr_state,\" - \",paste0(round(100*loan_by_state$`Total Loans ($)`/sum(loan_by_state$`Total Loans ($)`),1),\"%\"))\n  \n  loan_by_state_plot <- ggplot(loan_by_state[1:10,], aes(x = reorder(addr_state,-`Total Loans ($)`), \n                                                         y = (`Total Loans ($)`)/1e6, \n                                                         fill = I(\"dodgerblue4\"),\n                                                         alpha = I(rep(0.7,10)),\n                                                         col = I(\"grey29\"))) + \n                    geom_bar(stat = \"identity\") +\n                    theme(axis.text.x = element_text(angle = 55, hjust = 1)) +\n                    xlab(\"State - % of Total\") +\n                    ylab(\"Total Loans - Millions of $\")\n  \n  ## Aggregating up by loan amount ##\n  loan_amnt_tmp <- loan_data_tmp$loan_amnt\n  \n  loan_amnt_hist <- qplot(loan_amnt_tmp, fill = I(\"dodgerblue4\"), \n                           alpha = I(0.7), col = I(\"grey29\")) + xlab(\"Loan Amount\") + ylab(\"Count\") + \n                            geom_vline(aes(xintercept = mean(loan_amnt_tmp)), \n                                       color = \"dodgerblue4\", \n                                       linetype = \"dashed\", \n                                       size = 2) +\n                            annotate(\"text\", x = Inf, y = Inf, \n                                     label = sprintf(\"\\n Mean: %s  \\n Average Deviation: %s   \\n Skewness: %s   \\n Kurtosis: %s   \",\n                                                     round(mean(loan_amnt_tmp)),\n                                                     round(mean(abs(loan_amnt_tmp-mean(loan_amnt_tmp)))),\n                                                     round(skewness(loan_amnt_tmp),2),\n                                                     round(kurtosis(loan_amnt_tmp),2)), \n                                     vjust = 1, hjust = 1)\n  \n  # Arranging plots into grid\n  grid.arrange(loan_by_emp_plot, loan_by_purp_plot, loan_by_state_plot, loan_amnt_hist,\n               widths = c(4,4), heights = c(4,3),   \n               top = textGrob(sprintf(\"Grade %s Loan Volume by Employment, Purpose, State, and Counts\",grade)))\n  \n  return(NULL)\n}\n# This seems to be a bug, but R errors out due on an obscure dplyr issue that is resolved with:\n# 1) Restarting the R session at this point\n# 2) Running library(ggplot2); library(dplyr); library(gridExtra); library(moments); library(grid)\n# 3) Running the rest of the chunks\n\n```\n\n## {.tabset .tabset-fade}\n\n### Grade A\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"A\"))\n```\n\n### Grade B\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"B\"))\n```\n\n### Grade C\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"C\"))\n```\n\n### Grade D\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"D\"))\n```\n\n### Grade E\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"E\"))\n```\n\n### Grade F\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"F\"))\n```\n\n### Grade G\n\n```{r, message = FALSE, fig.width = 8, fig.height = 7}\nnull <- grid.draw(grade_plotter(\"G\"))\n```\n \n## {.tabset .tabset-fade}\n\nThe relative orders of the purpose, state, and job title don't change much between grades. The distribution of the loan size does shift to the right as the grade decreases. That is, people that are riskier tend to borrow more than those that are less risky. As the grade decreases there is a greater tendency to use the loan for debt consolidation. \n\n## Summary\n\nThere's still lots of exploratory analysis left but in the interest of keeping this short, we should move on. We'll also do plenty of data scrubbing and plotting when trying to build an intuition behind the mechanics of our predictive models. For now, let's briefly summarize what we've done.\n\nWe've broken out the data set into continuous and categorical variables. These were scrubbed, summarized, and analyzed for sparsity. Once we were comfortable with the data set, we moved on to visualizing the relationships between the variables. We broke out loan volume by state, job, and purpose. We also looked at the distribution of interest rate by loan grade and dived deeper into each grade's statistics. Now that we have a reasonably clean data set and some aggregate information on the variables, we can move on to building models for inference and prediction. \n\nWe could look into what determines a borrower's interest rate. The interest rates are actually explicitly dictated by the [sub-grade rating](https://www.lendingclub.com/public/rates-and-fees.action), which explains the lumpiness in the grade distributions above. Therefore, it would be interesting to look at what makes a borrower fall under a certain sub-grade since that directly impacts the interest rate.",
    "created" : 1498177526199.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2881869286",
    "id" : "33A03964",
    "lastKnownWriteTime" : 1499737766,
    "last_content_update" : 1499737766992,
    "path" : "~/OneDrive/R/Random Projects/Loan-Analysis/Analysis/ExploratoryAnalysis.Rmd",
    "project_path" : "Analysis/ExploratoryAnalysis.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "ignored_words" : "br\n",
        "tempName" : "Untitled2"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}